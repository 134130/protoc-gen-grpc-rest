package genrestgrpc

import (
	"google.golang.org/grpc/grpclog"
	"strconv"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage   = protogen.GoImportPath("context")
	httpPackage      = protogen.GoImportPath("net/http")
	ioPackage        = protogen.GoImportPath("io")
	fmtPackage       = protogen.GoImportPath("fmt")
	stringsPackage   = protogen.GoImportPath("strings")
	bytesPackage     = protogen.GoImportPath("bytes")
	protoPackage     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + ".pb.rest.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-rest. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	GenerateFileContent(gen, file, g)
	return g
}

func GenerateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	for _, service := range file.Services {
		genService(gen, file, g, service)
	}
}
func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	clientName := service.GoName + "RestClient"

	g.P("// ", clientName, " is the client API for ", service.GoName, " service.")

	// Client interface
	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		g.AnnotateSymbol(clientName+"."+method.GoName, protogen.Annotation{
			Location: method.Location,
		})
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P(method.Comments.Leading, clientSignature(g, method))
	}
	g.P("}")
	g.P()

	// Client structure
	g.P("type ", unexport(clientName), " struct {")
	g.P("c *", httpPackage.Ident("Client"))
	g.P("target string")
	g.P("}")
	g.P()

	// NewClientF factory
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P(deprecationComment)
	}
	g.P("func New", clientName, "(c *", httpPackage.Ident("Client"), ", target string) ", clientName, " {")
	g.P("return &", unexport(clientName), "{")
	g.P("c: c,")
	g.P("target: target,")
	g.P("}")
	g.P("}")
	g.P()

	var methodIndex, streamIndex int
	// Client method implementations
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
			// Unary RPC method
			genClientMethod(gen, file, g, method, methodIndex)
			methodIndex++
		} else {
			// Streaming RPC method
			genClientMethod(gen, file, g, method, streamIndex)
			streamIndex++
		}
	}

	// Client internal method implementations
	g.P("func (c *", unexport(clientName), ") do(ctx ", contextPackage.Ident("Context"), ", client *", httpPackage.Ident("Client"), ", httpMethod, url string, req, res ", protoPackage.Ident("Message"), ") error {")
	g.P("var m []byte")
	g.P("var err error")
	g.P()
	g.P("if req != nil {")
	g.P("if m, err = ", protojsonPackage.Ident("Marshal"), "(req); err != nil {")
	g.P("return fmt.Errorf(\"failed to marshal request: %w\", err)")
	g.P("}")
	g.P("}")
	g.P()
	g.P("r, err := ", httpPackage.Ident("NewRequestWithContext"), "(ctx, httpMethod, url, ", bytesPackage.Ident("NewReader"), "(m))")
	g.P("if err != nil {")
	g.P("return fmt.Errorf(\"failed to create request: %w\", err)")
	g.P("}")
	g.P()
	g.P("r.Header.Set(\"Content-Type\", \"application/json\")")
	g.P()
	g.P("resp, err := c.c.Do(r)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P()
	g.P("data, err := ", ioPackage.Ident("ReadAll"), "(resp.Body)")
	g.P("if err != nil {")
	g.P("return fmt.Errorf(\"failed to read response body: %w\", err)")
	g.P("}")
	g.P("defer resp.Body.Close()")
	g.P()
	g.P("if res == nil {")
	g.P("return nil")
	g.P("}")
	g.P()
	g.P("contentType := resp.Header.Get(\"Content-Type\")")
	g.P("if contentType != \"application/json\" {")
	g.P("switch {")
	g.P("case resp.StatusCode < ", httpPackage.Ident("StatusOK"), " || resp.StatusCode > ", httpPackage.Ident("StatusPartialContent"), ":")
	g.P("message := \"unknown\"")
	g.P("if ", stringsPackage.Ident("HasPrefix"), "(contentType, \"text/\") {")
	g.P("message = ", stringsPackage.Ident("TrimSpace"), " (string(data))")
	g.P("}")
	g.P("return ", fmtPackage.Ident("Errorf"), "(\"%d - %s\", resp.StatusCode, message)")
	g.P("default:")
	g.P("return ", fmtPackage.Ident("Errorf"), "(\"received unexpected content-type: %s\", string(contentType))")
	g.P("}")
	g.P("}")
	g.P()
	g.P("if err := ", protojsonPackage.Ident("Unmarshal"), "(data, res); err != nil {")
	g.P("return ", fmtPackage.Ident("Errorf"), "(\"failed to unmarshal response: %w\", err)")
	g.P("}")
	g.P("return nil")
	g.P("}")
	g.P()
}

func clientSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		return "// TODO: streaming client and server methods are not supported yet."
	}

	s := method.GoName + "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
	if !method.Desc.IsStreamingClient() {
		if method.Input.Desc.FullName() != googleEmptyFullName {
			s += ", req *" + g.QualifiedGoIdent(method.Input.GoIdent)
		}
	}
	s += ") ("
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		if method.Output.Desc.FullName() != googleEmptyFullName {
			s += "*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", "
		}
	}
	s += " error)"
	return s
}

func genClientMethod(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, method *protogen.Method, index int) {
	service := method.Parent
	// sname := fmt.Sprintf("/%s/%s", service.Desc.FullName(), method.Desc.Name())

	httpExt := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
	if httpExt == nil {
		return
	}

	var httpMethod, httpPath string
	switch m := httpExt.GetPattern().(type) {
	case *annotations.HttpRule_Get:

		httpMethod = "http.MethodGet"
		httpPath = m.Get
	case *annotations.HttpRule_Post:
		httpMethod = "http.MethodPost"
		httpPath = m.Post
	case *annotations.HttpRule_Put:
		httpMethod = "http.MethodPut"
		httpPath = m.Put
	case *annotations.HttpRule_Delete:
		httpMethod = "http.MethodDelete"
		httpPath = m.Delete
	case *annotations.HttpRule_Patch:
		httpMethod = "http.MethodPatch"
		httpPath = m.Patch
	default:
		grpclog.Errorf("unsupported http method: %v", m)
	}

	if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
		g.P(deprecationComment)
	}
	g.P("func (c *", unexport(service.GoName), "RestClient) ", clientSignature(g, method), "{")
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		g.P("return nil, fmt.Errorf(\"streaming client and server methods are not supported yet\")")
	} else {
		// Unary RPC method
		g.P("url := c.target + ", strconv.Quote(httpPath))

		reqExists := method.Input.Desc.FullName() != googleEmptyFullName
		resExists := method.Output.Desc.FullName() != googleEmptyFullName

		if resExists {
			g.P("res := new(", method.Output.GoIdent, ")")
		}

		switch {
		case reqExists && resExists:
			g.P("if err := c.do(ctx, c.c, ", httpMethod, ", url, req, res); err != nil {")
			g.P("return nil, err")
			g.P("}")
			g.P("return res, nil")
		case reqExists:
			g.P("if err := c.do(ctx, c.c, ", httpMethod, ", url, req, nil); err != nil {")
			g.P("return err")
			g.P("}")
			g.P("return nil")
		case resExists:
			g.P("if err := c.do(ctx, c.c, ", httpMethod, ", url, nil, res); err != nil {")
			g.P("return nil, err")
			g.P("}")
			g.P("return res, nil")
		default:
			g.P("if err := c.do(ctx, c.c, ", httpMethod, ", url, nil, nil); err != nil {")
			g.P("return err")
			g.P("}")
			g.P("return nil")
		}
	}
	g.P("}")
	g.P()
}

const deprecationComment = "// Deprecated: Do not use."
const googleEmptyFullName = "google.protobuf.Empty"

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }
